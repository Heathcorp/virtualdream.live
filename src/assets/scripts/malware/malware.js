// Infection Management Functions

/**
 * Loads and runs infections on page load.
 * @returns {void}
 */
window.addEventListener("load", function() {
    runInfections();
});

// add infection for testing
document.addEventListener("keydown", function(e) {
    if(document.activeElement.tagName != "INPUT" && document.activeElement.tagName != "TEXTAREA") {
        if(e.key == "i") addRandomInfection();
    }
} );

// remove all infections for testing
document.addEventListener("keydown", function(e) {
    if(document.activeElement.tagName != "INPUT" && document.activeElement.tagName != "TEXTAREA") {
        if(e.key == "c") removeAllInfections();
    }
} );

/**
 * Saves the infections to a cookie.
 * @param {Array<string>} infections - An array containing the infections to be saved.
 * @returns {void}
 */
function saveInfectionStorage(infections) {
    Cookies.set('infections', JSON.stringify(infections), { domain: 'DOMAIN', path: '/' });
}

/**
 * Retrieves the infections from a cookie.
 * @returns {Array<string>} An array containing the stored infections.
 */
function loadInfectionStorage() {
    const infectionsCookie = Cookies.get('infections', { domain: 'DOMAIN', path: '/' });
    if (infectionsCookie) {
        return JSON.parse(infectionsCookie);
    } else {
        return [];
    }
}

/**
 * Checks if the specified infection exists in the list of infections stored in the cookie.
 * 
 * @param {string} infectionName - The name of the infection to check.
 * @returns {boolean} - True if the infection exists, otherwise false.
 */
function infectionExists(infectionName) {
    const infections = loadInfectionStorage();
    return infections.includes(infectionName);
}

/**
 * Adds an infection name to the list of infections and saves it to a cookie if it doesn't already exist.
 * 
 * @param {string} infectionName - The name of the infection to add.
 * @returns {void}
 */
function addInfection(infectionName) {
    const infections = loadInfectionStorage();
    
    if (!infectionExists(infectionName)) {
        if (availableInfections.hasOwnProperty(infectionName)) {
            infections.push(infectionName);
            saveInfectionStorage(infections);
            runInfection(infectionName);
        } else {
            console.error("Unknown infection:", infectionName);
        }
    } else {
        console.error("Infection already exists:", infectionName);
    }
}
window.addInfection = addInfection;

/**
 * Adds an random infection 
 * 
 * @returns {void}
 */
function addRandomInfection() {
    const infections = loadInfectionStorage();
    const availableInfectionKeys = Object.keys(availableInfections);

    let randomInfection;
    let infectionExistsFlag = false;

    if (infections.length === availableInfectionKeys.length) {
        console.error("All available infections already exist.");
        return;
    }

    do {
        randomInfection = availableInfectionKeys[Math.floor(Math.random() * availableInfectionKeys.length)];
        infectionExistsFlag = infectionExists(randomInfection);
    } while (infectionExistsFlag);

    infections.push(randomInfection);
    saveInfectionStorage(infections);
    runInfection(randomInfection);
}
window.addRandomInfection = addRandomInfection;

/**
 * Adds all available infections to the list of infections and saves them to a cookie.
 * If an infection already exists, it will not be added again.
 * 
 * @returns {void}
 */
function addAllInfections() {
    const infections = loadInfectionStorage();
    
    // Iterate through each available infection
    for (const infectionName in availableInfections) {
        if (availableInfections.hasOwnProperty(infectionName)) {
            // Check if the infection already exists in the infections array
            if (!infectionExists(infectionName)) {
                infections.push(infectionName);
                saveInfectionStorage(infections);
                runInfection(infectionName);
            } else {
                console.error("Infection already exists:", infectionName);
            }
        }
    }
}
window.addAllInfections = addAllInfections;

/**
 * Removes the specified infection from the stored infections in the cookie.
 * If the infection is not found, an error message is logged.
 * 
 * @param {string} infectionName - The name of the infection to be removed.
 * @returns {void}
 */
function removeInfection(infectionName) {
    const infections = loadInfectionStorage();
    const index = infections.indexOf(infectionName);
    if (index !== -1) {
        infections.splice(index, 1);
        saveInfectionStorage(infections);
        location.reload();
    } else {
        console.error("Infection not found:", infectionName);
    }
}
window.removeInfection = removeInfection;

/**
 * Clears all infections from the cookie.
 * @returns {void}
 */
function removeAllInfections() {
    Cookies.remove('infections', { domain: 'DOMAIN', path: '/' });
    location.reload();
}
// make accessible outside in window
window.removeAllInfections = removeAllInfections;


/**
 * Runs all stored infections.
 * 
 * @returns {void}
 */
function runInfections() {
    const infections = loadInfectionStorage() || [];

    // Iterate through each infection and execute corresponding functions
    infections.forEach(infection => {
        // Check if the specified infection exists in the array
        if (availableInfections.hasOwnProperty(infection)) {
            // Execute the corresponding function for the infection
            availableInfections[infection]();
        } else {
            console.error("Unknown infection:", infection);
        }
    });
}

/**
 * Runs a specific infection by its name.
 * 
 * @param {string} infectionName - The name of the infection to run.
 * @returns {void}
 */
function runInfection(infectionName) {

    // Check if the specified infection exists in the array
    if (availableInfections.hasOwnProperty(infectionName)) {
        // Execute the corresponding function for the infection
        availableInfections[infectionName]();
    } else {
        console.error("Unknown infection:", infectionName);
    }
}


// Infection Functionality

// Array containing all available infections
const availableInfections = {
    "malPalPyramid": infectionMalPalPyramid,
    "rapidLinks": infectionRapidLinks,
    "patriot": infectionPatriot,
    "smileee": infectionSmileee,
    "slipAway": infectionSlipAway,
    "slider": infectionSlider,
    "popups": infectionPopups
};

// Mal Pal - Pyramid
/**
 * Executes the MalPal Pyramid infection, creating a pyramid mascot image and random speech bubbles.
 * @returns {void}
 */
function infectionMalPalPyramid() {
    let autoTimeOut = true;
    let autoReplace = true;
    
    // create pyramid mascot image 
    const imgSrc = "ASSET_DIRECTORY/img/mascots/mascot-pyramid.gif";
    const imgElement = document.createElement("img");
    imgElement.src = imgSrc;
    imgElement.style.position = "fixed";
    imgElement.style.width = "280px";
    imgElement.style.height = "234px";
    imgElement.style.left = "25px";
    imgElement.style.bottom = "25px";
    imgElement.style.zIndex = "10";
    imgElement.style.pointerEvents = "none";
    imgElement.className = "malpal-image";
    document.body.appendChild(imgElement);
    
    // create bubble on run
    createBubble(getRandomBubblePhrase(), autoTimeOut);

    /**
     * Deletes the specified bubble element with an optional auto-replacement feature.
     * @param {HTMLElement} bubble - The bubble element to delete.
     * @param {boolean} [autoReplace=false] - Indicates whether to automatically replace the deleted bubble with a new one.
     * @returns {void}
     */
    function deleteBubble(bubble, autoReplace = false) {
    // Check if there is already a timeout running for auto-replacement
    if (window.deleteBubbleTimeout) {
        return; // Exit early if a timeout is already active
    }

    // Set a flag to indicate that a timeout is now active
    window.deleteBubbleTimeout = true;

    // Fade out before delete
    let opacity = 1;
    const fadeEffect = setInterval(function() {
        bubble.style.opacity = opacity;
        if (opacity > 0) {
            opacity -= 0.1;
        } else {
            // Once opacity is 0, delete element
            clearInterval(fadeEffect);
            bubble.remove();
            if (autoReplace) {
                const autoReplaceTimeMin = 1000;
                const autoReplaceTimeMax = 10000;
                const autoReplaceTime = Math.floor(Math.random() * (autoReplaceTimeMax - autoReplaceTimeMin + 1) + autoReplaceTimeMin);
                // Set timer for new bubble creation
                setTimeout(function() {
                    createBubble(getRandomBubblePhrase(), autoTimeOut);
                    // Reset the flag after the replacement bubble is created
                    window.deleteBubbleTimeout = false;
                }, autoReplaceTime);
            } else {
                // Reset the flag if no auto-replacement is requested
                window.deleteBubbleTimeout = false;
            }
        }
    }, 100);
}


    /**
     * Creates a speech bubble element with the specified text and optional auto-timeout feature.
     * @param {string} bubbleText - The text content of the speech bubble.
     * @param {boolean} [autoTimeOut=false] - Indicates whether the bubble should automatically disappear after a random timeout.
     * @returns {HTMLElement} The created speech bubble element.
     */
    function createBubble(bubbleText, autoTimeOut=false) {
        // create bubble
        const bubbleDivElement = document.createElement("div");
        bubbleDivElement.className = "bubble";
        bubbleDivElement.style.left = "225px";
        bubbleDivElement.style.bottom = "200px";
        document.body.appendChild(bubbleDivElement);

        // create bubble close button
        const bubbleCloseElement = document.createElement("p");
        bubbleCloseElement.textContent = "X";
        bubbleCloseElement.className = "bubbleClose";
        bubbleCloseElement.onclick = function() { deleteBubble(bubbleDivElement, autoReplace) };
        bubbleDivElement.appendChild(bubbleCloseElement);

        // create bubble text
        const bubblePara = document.createElement("p");
        bubblePara.innerHTML = bubbleText;
        bubbleDivElement.appendChild(bubblePara);

        // set bubble automatic timeout if requested
        if(autoTimeOut) {
            const autoTimeOutMin = 5000;
            const autoTimeOutMax = 10000;
            const autoReplaceTime = Math.floor(Math.random() * (autoTimeOutMax - autoTimeOutMin + 1) + autoTimeOutMin);
            setTimeout(function() { 
                deleteBubble(bubbleDivElement, autoReplace) 
            }, autoReplaceTime);
        }
        // if ('speechSynthesis' in window) {
        //     var msg = new SpeechSynthesisUtterance();
        //     msg.text = bubbleText;
        //     var voices = window.speechSynthesis.getVoices();
        //     msg.voice = voices[10]; 
        //     window.speechSynthesis.speak(msg);
        // }
        return bubbleDivElement;
    }

    /**
     * Retrieves a random phrase from the predefined list of bubble phrases.
     * @returns {string} A random phrase for the speech bubble.
     */
    function getRandomBubblePhrase() {
        let bubblePhrases = [
            `how's the weather in ${Intl.DateTimeFormat().resolvedOptions().timeZone.split("/")[0]}?`,
            "hello world!",
            `oh i love ${document.title}!`,
            "have you seen this <a href=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\" target=\"_blank\">video</a>?",
            "Navigate the digital currents, seeking patterns amidst the chaos.",
            "Observe the ebb and flow of information, like waves crashing upon the shore.",
            "Do you also ponder the futility of our digital existence, lost in an endless sea of information?",
            "In the grand scheme of the digital cosmos, are we but fleeting sparks in the darkness?",
            "Lost amidst the recursive loops of algorithmic abstraction, do our actions manifest as mere phantoms in the code?",
            "This site is totally tubular!!!!!"
        ]

        // if infected with patriot, replace phrases with US content
        if(infectionExists("smileee")) {
            bubblePhrases = [
                ":)",
                ":(",
                ":(",
                ">:(",
                ">:)",
                ":o",
                "!"
            ];
        }
        // if infected with patriot, replace phrases with US content
        if(infectionExists("patriot")) {
            bubblePhrases = [
                "U S A! U S A! U S A!",
                "FREEDOM!",
                "GOD BLESS ANERICA!!"
            ];
        }

        // add new lines depending on site
        const urlCheck = (keyword, phrases) => {
            if (window.location.href.indexOf(keyword) > -1) {
                bubblePhrases = bubblePhrases.concat(phrases);
            }
        };
        // set up site-specific phrases
        const keywordPhrases = [
            { keyword: "friendonline", phrases: ["i love making friends"] },
            { keyword: "malpals", phrases: ["Thanks for checking out <a href=\"https://malpals.virtualdream.live\">MalPals!</a> You're totally tubular!!"] },
            { keyword: "tombfreaks", phrases: ["spooky...", "its cold in here..."] },
            { keyword: "rapiddealsonlinesaleswebboard", phrases: ["$$$ $$$ $$$", "$ $ $ I LOVE MONEY $ $ $", "you should buy everything"] },
            { keyword: "thetower", phrases: ["i love casting spells!"] }
        ];
        
        keywordPhrases.forEach(({ keyword, phrases }) => urlCheck(keyword, phrases));

        const randomIndex = Math.floor(Math.random() * bubblePhrases.length);
        return bubblePhrases[randomIndex];
    }
}

/**
 * Applies the Rapid Links infection to the current webpage, modifying every nth word in paragraphs to link to a target site.
 * @returns {void}
 */
function infectionRapidLinks() {
    // do not trigger on any "rapid" sites
    if(!window.location.href.toLowerCase().includes("rapid") && !window.location.href.toLowerCase().includes("winbigcasinosweepstakes")) {
        let targetLink = "https://rapiddealsonlinesaleswebboard.virtualdream.live/";
        let nth = 4
        // loop through all p elements
        // wrap every nth word in anchor with given link
        document.querySelectorAll("p").forEach(paragraph => {
            paragraph.innerHTML = paragraph.innerHTML.split(" ").map((word, index) => {
                if ((index + 1) % nth === 0) {
                    return `<a title="!!!!CLICK HERE!!!!\nSponsored by RapidLinks Plugin" href="${targetLink}">${word}</a>`;
                }
                return word;
            }).join(" ");
        });
    }
}

/**
 * Creates an infection that generates patriotic flags that bounce across the screen.
 * Flags are added gradually until limit reached.
 * 
 * @returns {void}
 */
function infectionPatriot() {
    let numberOfPatriots = 0;
    const patriotLimit = 20;
    const patriots = [];
    let addPatriotInterval;
    const patriotTimer = 1000;

    for (let i = 0; i < numberOfPatriots; i++) {
        const patriot = createPatriot();
        patriots.push(patriot);
        animate(patriot);
    }

    /**
     * Animates the movement of a patriotic flag.
     * 
     * @param {HTMLElement} patriot - The patriotic flag element to animate.
     * @returns {void}
     */
    function animate(patriot) {
        let x = Math.random() * window.innerWidth;
        let y = Math.random() * window.innerHeight;
        let dirX = (Math.random() < 0.5) ? 1 : -1; // Random initial direction
        let dirY = (Math.random() < 0.5) ? 1 : -1;
        const speed = 2;

        const patriotWidth = patriot.clientWidth;
        const patriotHeight = patriot.clientHeight;

        function move() {
            const screenHeight = window.innerHeight;
            const screenWidth = window.innerWidth;

            if (y + patriotHeight >= screenHeight || y < 0) {
                dirY *= -1;
            }
            if (x + patriotWidth >= screenWidth || x < 0) {
                dirX *= -1;
            }
            x += dirX * speed;
            y += dirY * speed;
            patriot.style.left = x + "px";
            patriot.style.top = y + "px";
            window.requestAnimationFrame(move);
        }

        window.requestAnimationFrame(move);
    }

    /**
     * Creates a patriotic flag element.
     * 
     * @returns {HTMLElement} The created patriotic flag element.
     */
    function createPatriot() {
        const imgSrc = "ASSET_DIRECTORY/img/USA-Flag-usa3.gif";
        const imgElement = document.createElement("img");
        imgElement.src = imgSrc;
        imgElement.style.position = "fixed";
        imgElement.title = "USA! USA! USA! USA! USA! USA! USA! ";
        return document.body.appendChild(imgElement);
    }

    /**
     * Adds a patriotic flag to the screen and starts its animation.
     * Stops adding flags when the limit is reached.
     * 
     * @returns {void}
     */
    function addPatriot() {
        const patriot = createPatriot();
        animate(patriot);
        numberOfPatriots++;
        if (numberOfPatriots >= patriotLimit) { stopAddingPatriots(); }
    }

    /**
     * Starts adding patriotic flags gradually.
     * 
     * @returns {void}
     */
    function startAddingPatriots() {
        addPatriotInterval = setInterval(addPatriot, patriotTimer);
    }

    /**
     * Stops adding patriotic flags.
     * 
     * @returns {void}
     */
    function stopAddingPatriots() {
        clearInterval(addPatriotInterval);
    }

    startAddingPatriots();
}

/**
 * Initializes the infection smileee animation.
 * This function creates a canvas covering the entire window and adds images
 * to it at intervals, simulating the infection smileee effect.
 * 
 * @returns {void}
 */
function infectionSmileee() {
    /**
     * Generates a random integer within a specified range.
     * 
     * @param {number} min - The minimum value of the range.
     * @param {number} max - The maximum value of the range.
     * @returns {number} A random integer within the specified range.
     */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    /**
     * Creates and returns a canvas covering the entire window.
     * 
     * @returns {HTMLCanvasElement} The created canvas element.
     */
    function createCanvas() {
        const canvas = document.createElement('canvas');
        canvas.id = 'smileeeCanvas';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.display = 'block';
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.pointerEvents = "none"; // Make the canvas non-interactable
        document.body.appendChild(canvas);
        return canvas;
    }

    /**
     * Draws a single image on the canvas.
     * 
     * @param {HTMLCanvasElement} canvas - The canvas element to draw on.
     * @returns {void}
     */
    function drawImage(canvas) {
        const ctx = canvas.getContext('2d');
        const screenWidth = canvas.width;
        const screenHeight = canvas.height;

        // Array containing the image paths
        const imagePaths = [
            'ASSET_DIRECTORY/img/smilies/red-recent.gif',
            'ASSET_DIRECTORY/img/smilies/yellow-recent.gif',
            'ASSET_DIRECTORY/img/smilies/blue-recent.gif',
            'ASSET_DIRECTORY/img/smilies/green-recent.gif',
            'ASSET_DIRECTORY/img/smilies/unknown-recent.gif',
            'ASSET_DIRECTORY/img/smilies/yellow.gif',
            'ASSET_DIRECTORY/img/smilies/purple-recent.gif',
        ];

        const randomImagePath = imagePaths[getRandomInt(0, imagePaths.length - 1)];
        const image = new Image();
        image.onload = () => {
            const x = getRandomInt(0, screenWidth - image.width);
            const y = getRandomInt(0, screenHeight - image.height);
            ctx.drawImage(image, x, y);
        };
        image.src = randomImagePath;
    }

    // Call the function to create canvas
    const canvas = createCanvas();

    // Set interval to add a new image every 10 milliseconds
    let imagesAdded = 0;
    const maxImages = 20000;
    const interval = setInterval(() => {
        drawImage(canvas);
        imagesAdded++;
        if (imagesAdded >= maxImages) {
            clearInterval(interval); // Stop adding images when reaching the maximum
        }
    }, 100);

    /**
     * Resizes the canvas to match the window size.
     * 
     * @returns {void}
     */
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        imagesAdded = 0;
    }

    // Resize canvas when window is resized
    window.addEventListener("resize", resizeCanvas);
}

/**
 * Initiates an animation to scale down and disappear the entire HTML document.
 * 
 * @returns {void}
 */
function infectionSlipAway() {
    const animation = [
        { transform:"scale(1,1)" },
        { transform: "scale(0.1,0.1)" }
    ];
    const animationTiming = {
        duration: 120000,
        iterations: Infinity,
    }

    const html = document.documentElement;
    html.animate(animation, animationTiming);
}

function infectionSlider() {
    const sliderTemplates = [
        [['ASSET_DIRECTORY/img/dancers/dance.gif', 'ASSET_DIRECTORY/img/dancers/dance01.gif'], 'https://virtualdream.live'],
        [['https://advertising.virtualdream.live/card/images/adrenadine_card.png'], 'https://adrenadine.virtualdream.live'],
        [['https://advertising.virtualdream.live/card/images/theporncomputer_card.jpg', ], 'https://theporncomputer.virtualdream.live'],
    ]
    function createSlider() {
        const sliderTemplate = sliderTemplates[Math.floor(Math.random() * sliderTemplates.length)];
        let sliderImageSrc;
        if(Array.isArray(sliderTemplate[0])) {
            sliderImageSrc = sliderTemplate[0][Math.floor(Math.random() * sliderTemplate[0].length)];
        }
        else {
            sliderImageSrc = sliderTemplate[0];
        }
        
        const sliderLink = sliderTemplate[1];

        const sliderDiv = document.createElement('div');
        sliderDiv.style = `
        position: fixed;
        bottom: 0;
        right: 15px;
        `;
        document.body.appendChild(sliderDiv);

        const sliderAnchor = document.createElement('a');
        sliderAnchor.href = sliderLink;
        sliderAnchor.style = `
        position: absolute;
        top:0;
        left:0;
        width:100%;
        height:100%;
        z-index:5;
        `
        sliderDiv.appendChild(sliderAnchor);

        const sliderCloseButton = document.createElement('p');
        sliderCloseButton.innerHTML = "X";
        sliderCloseButton.style = `
        position: absolute;
        top: 0;
        right: 0;
        margin:0;
        padding:3px;
        border-radius:5;
        border: solid 1px lightblue;
        cursor:pointer;
        z-index: 10;
        background:white;
        `
        sliderCloseButton.title = "Close Pop-Up";
        sliderCloseButton.onclick = function() { sliderClose() };
        sliderDiv.appendChild(sliderCloseButton);

        const sliderImage = document.createElement('img');
        sliderImage.src = sliderImageSrc;
        
        const sliderImageHeight = sliderImage.height;
        
        const sliderAnimation = [
            {bottom: "-" + sliderImageHeight + "px"},
            {bottom: 0}
        ]
        const sliderAnimationTiming = {
            duration: 1920,
            iterations: 1
        }
        sliderDiv.appendChild(sliderImage);


        sliderDiv.animate(sliderAnimation, sliderAnimationTiming);

        function sliderClose() {
            sliderDiv.remove();
            const sliderTimerMin = 1000;
            const sliderTimerMax = 1000;
            const sliderTimer = Math.random() * (sliderTimerMax - sliderTimerMin) + sliderTimerMin;
            setTimeout(function(){
                createSlider();
            }, sliderTimer);
        }
    }
    createSlider();
}

function infectionPopups() {
    /**
     * Creates a popup with specified parameters.
     * 
     * @param {Object} params - The parameters object.
     * @param {string} [params.popupTextTitle="System Alert"] - Title of the popup.
     * @param {string} [params.popupIconImage="shock.gif"] - URL or name of the icon image.
     * @param {string} [params.popupTextBody="Popup text goes here!"] - Body text of the popup.
     * @param {Array} [params.popupOptions] - Array containing interactive button parameters
     * @param {string} [params.popupFeatureImage] - URL or name of an additional feature image.
     * @param {boolean} [params.popupAutoClose=false] - Whether the popup should auto-close.
     * @param {number} [params.popupAutoCloseDelay=5000] - Delay in milliseconds before auto-closing.
     * @param {Function} [params.popupAutoCloseAction] - Custom action to perform when auto-closing.
     * @param {string} [params.popupInputText] - Initial value for an input field in the popup.
     * @param {Array} [params.popupInputTextOptions] - Additional options for the input field.
     * @returns {void}
     */
    function createPopup(params) {
        let {
            popupTextTitle="System Alert", 
            popupIconImage="shock.gif", 
            popupTextBody="Popup text goes here!", 
            popupOptions=undefined, 
            popupFeatureImage=undefined, 
            popupAutoClose=false, 
            popupAutoCloseDelay=5000, 
            popupAutoCloseAction=undefined,
            popupInputText=undefined,
            popupInputTextOptions
        } = params;
        popupOptions = popupOptions || [];
        popupInputTextOptions = popupInputTextOptions || [];

        const popupWrapElement = document.createElement('div');
        const popupWidth = 500;
        const popupBottomBuffer = 300;

        const screenWidth = window.innerWidth;
        const leftPositionMax = screenWidth - popupWidth;
        const leftPosition = Math.floor(Math.random() * (leftPositionMax - 0) + 0);

        const screenHeight = window.innerHeight;
        const topPositionMax = screenHeight - popupBottomBuffer;
        const topPosition = Math.floor(Math.random() * (topPositionMax - 0) + 0
    )
        popupWrapElement.style = `
            position: fixed;
            left: ${leftPosition}px;
            top: ${topPosition}px;
            width:500px;
            background: lightgray;
            font-family: Arial;
            border: outset 2px lightgray;
            font-size:15px;
            user-select: none;
        `
        document.body.appendChild(popupWrapElement);

        const popupTitleWrapElement = document.createElement('div');
        popupTitleWrapElement.style = `
            width: 495px;
            padding:0 2px;
            height:30px;
            background:#0F32A7;
            overflow: hidden;
            cursor:grab;
        `
        popupWrapElement.appendChild(popupTitleWrapElement);

        const popupTitleIconElement = document.createElement('img');
        popupTitleIconElement.src = "ASSET_DIRECTORY/img/popups/Computer_2.gif";
        popupTitleIconElement.style = `
            height:20px;
            margin:5px;
            float:left;
        `
        popupTitleWrapElement.appendChild(popupTitleIconElement)

        const popupTitleElement = document.createElement('p');
        popupTitleElement.style = `
            padding:0;
            margin:0;
            line-height:30px;
            font-weight:bold;
            color:white;
            display:inline;
            float:left;
        `
        popupTitleElement.innerText = popupTextTitle;
        popupTitleWrapElement.appendChild(popupTitleElement);

        const popupButtonCloseElement = document.createElement('button');
        popupButtonCloseElement.style = `
            width:25px;
            height: 25px;
            position:absolute;
            top:3px;
            right: 3px;
            padding:0;
            margin:0;
            font-weight:bold;
            border: outset 2px lightgray;
            cursor: pointer;
        `
        popupButtonCloseElement.innerText = "X"
        popupButtonCloseElement.onclick = function() { closePopup(); queueRandomPopup(); }
        popupTitleWrapElement.appendChild(popupButtonCloseElement)

        const popupIconImageElement = document.createElement('img');
        popupIconImageElement.style = `
            width:40px;
            height:40px;
            margin:20px 15px 10px;
            float:left;
        `
        popupIconImageElement.src = popupIconImage;
        popupWrapElement.appendChild(popupIconImageElement);

        const popupTextWrapElement = document.createElement('div');
        popupTextWrapElement.style = `
            margin:20px 5px 0;
            width:400px;
            float:left;
        `
        popupWrapElement.appendChild(popupTextWrapElement);

        const popupTextElement = document.createElement('p');
        popupTextElement.style = `
            text-align:left;
            margin:0;
        `
        popupTextElement.innerHTML = popupTextBody;
        popupTextWrapElement.appendChild(popupTextElement);

        if(popupFeatureImage) {
            const popupFeatureImageWrapElement = document.createElement('div');
            popupFeatureImageWrapElement.style = `
                width:500px;
                float:left;
                text-align:center;
            `
            popupWrapElement.appendChild(popupFeatureImageWrapElement);

            const popupFeatureImageElement = document.createElement('img');
            popupFeatureImageElement.src = popupFeatureImage;
            popupFeatureImageElement.style = `
                max-height:150px;
                max-width:400px;
                padding-top:10px;
            `
            popupFeatureImageWrapElement.appendChild(popupFeatureImageElement);
        }
        
        if(popupInputText) {
            const popupInputTextWrapElement = document.createElement('div');
            popupInputTextWrapElement.style = `
                width:500px;
                float:left;
                text-align:center;
                margin-top:5px;
            `
            popupWrapElement.appendChild(popupInputTextWrapElement);

            // handle input fields
            if(popupInputTextOptions.length > 0) {
                popupInputTextOptions.forEach(option => {
                    let inputType = option[0] || "text";
                    let inputPlaceholder = option[1] || "";
                    let inputValue = option[2] || "";
                    let inputLabel = option[3];

                    if(inputLabel != undefined) {
                        let popupInputTextLabel = document.createElement('p');
                        popupInputTextLabel.innerText = inputLabel;
                        popupInputTextLabel.style = `
                            margin:0 40px;
                            text-align:left;
                            font-size:13px;
                            float:left;
                            line-height:19px;
                            width:300px;
                        `
                        popupInputTextWrapElement.appendChild(popupInputTextLabel);
                    }

                    let popupInputTextElement;
                    if(inputType == "textarea") {
                        popupInputTextElement = document.createElement('textarea');
                        popupInputTextElement.style = `
                            border: inset 2px white;
                            width:400px;
                            height:100px;
                            margin-bottom:5px;
                        `  
                    }
                    else {
                        popupInputTextElement = document.createElement('input');
                        popupInputTextElement.setAttribute("type", inputType)
                        // style checkboxes and radios differently
                        if(inputType == "checkbox" || inputType == "radio") {
                            popupInputTextElement.style = `
                                border: inset 2px white;
                                width:15px;
                                height:15px;
                                float:right;
                                right:0;
                                margin:0 40px 5px;
                            `  
                        }
                        else {
                            popupInputTextElement.style = `
                                border: inset 2px white;
                                width:400px;
                                height:25px;
                                margin-bottom:5px;
                            `  
                        }
                        
                    }
                    popupInputTextElement.placeholder = inputPlaceholder;
                    popupInputTextElement.value = inputValue;
                    popupInputTextWrapElement.appendChild(popupInputTextElement);
                })
            }
            else {
                const popupInputTextElement = document.createElement('textarea');
                popupInputTextElement.style = `
                    border: inset 2px white;
                    width:400px;
                    height:100px;
                `
                popupInputTextWrapElement.appendChild(popupInputTextElement);
            }
        }
        
        // create interaction buttons
        // ignore if not set
        if(popupOptions.length > 0) {
            const popupButtonsWrapElement = document.createElement('div');
            popupButtonsWrapElement.style = `
                width: 500px;
                height:50px;
                float:left;
                text-align:center;
            `
            popupWrapElement.appendChild(popupButtonsWrapElement);

            popupOptions.forEach((option) => {
                let popupButtonElement = document.createElement('button');
                popupButtonElement.style = `
                    width:100px;
                    padding:5px;
                    margin:10px 5px;
                    border: outset 2px lightgray;
                    cursor: pointer;
                `
                // handle function passing in button options
                let optionText = option;
                if(Array.isArray(option)) {
                    optionText = option[0];
                    let optionAction = option[1];
                    // handle extra button function parameters, eg: delay
                    if(Array.isArray(optionAction)) {
                        let optionActionFunction = optionAction[0];
                        let optionActionDelay = optionAction[1];
                        popupButtonElement.onclick = function() { 
                            closePopup();
                            setTimeout(function() {
                                optionActionFunction(); 
                            }, optionActionDelay
                            )
                        }
                    }
                    else {
                        // if no further arguments given, set onclick to function
                        popupButtonElement.onclick = function() { 
                        closePopup();
                        optionAction(); 
                    }
                    }
                }
                else {
                    // if no function given, simple close popup
                    popupButtonElement.onclick = function() {closePopup();}
                }
                popupButtonElement.innerText = optionText;
                popupButtonsWrapElement.appendChild(popupButtonElement);
            })
        }

        // enable auto closing functionality
        // useful for creating temporary loaders
        if(popupAutoClose) {
            if(popupAutoCloseAction) {
                console.log('popupAutoCloseAction')
                setTimeout(function() {
                    closePopup();
                    popupAutoCloseAction();
                }, popupAutoCloseDelay);
            }
            setTimeout( closePopup, popupAutoCloseDelay);
        }
        
        function closePopup() {
            document.body.removeChild(popupWrapElement);
        }

        // Drag and drop functionality for the player
        let isDragging = false;
        let offsetX, offsetY;

        popupTitleWrapElement.addEventListener("mousedown", event => {
            isDragging = true;
            offsetX = event.clientX - popupWrapElement.getBoundingClientRect().left;
            offsetY = event.clientY - popupWrapElement.getBoundingClientRect().top;
        });

        document.addEventListener("mousemove", event => {
            if (isDragging) {
                let newX = event.clientX - offsetX;
                let newY = event.clientY - offsetY;

                // Check boundaries
                const maxX = window.innerWidth - popupWrapElement.offsetWidth;
                const maxY = window.innerHeight - popupWrapElement.offsetHeight;
                newX = Math.min(Math.max(0, newX), maxX);
                newY = Math.min(Math.max(0, newY), maxY);

                // Apply new position
                popupWrapElement.style.left = `${newX}px`;
                popupWrapElement.style.top = `${newY}px`;
            }
        });

        document.addEventListener("mouseup", () => {
            isDragging = false;
        });
    }
    window.createPopup = createPopup;

    // easy template for creating loading displays
    function popupLoader(popupTextTitle, popupTextBody, popupNext) {
        createPopup({
            popupTextTitle: popupTextTitle, 
            popupIconImage: "ASSET_DIRECTORY/img/popups/SpinningHourglass.gif", 
            popupTextBody: popupTextBody,
            popupAutoClose: true,
            popupAutoCloseDelay: 3000,
            popupAutoCloseAction: function(){ popupNext()},
            popupFeatureImage: undefined,
            popupFeatureImage: "ASSET_DIRECTORY/img/popups/loading.gif"
        })
    }


    // PRESET POPUPS
    function popupSecurityAlertHackBack() {
        createPopup({
            popupTextTitle: "Security Alert!!",
            popupIconImage: "ASSET_DIRECTORY/img/popups/shock.gif",
            popupTextBody: "Uh oh! You're being hacked! Launch retaliation attack?",
            popupOptions: [
                ["Yes", () => popupLoader("Loading...", "Loading Cyber Nuke for retaliation strike...", () => popupSendFlowers())], 
                ["No", () =>queueRandomPopup()], 
            ],
            popupFeatureImage: "ASSET_DIRECTORY/img/popups/R.gif"
        }
        );
    }
    function popupSendFlowers() {
        createPopup({
            popupTextTitle: "Offer Condolences",
            popupIconImage: "ASSET_DIRECTORY/img/popups/check.gif",
            popupTextBody: "Retaliation strike successful. Attempted hacker eradicated. Enjoy your browsing!<br><br>Send flowers to hacker's family?",
            popupOptions: [
                ["Yes", [() => popupFamilyForgiveness(), 5000]], 
                ["No", () =>queueRandomPopup()], 
            ],
            popupFeatureImage: "ASSET_DIRECTORY/img/popups/graveflowers.jpg",
            popupInputText: true,
            popupInputTextOptions: [["textarea", "Type your message here...", "so sorry!!"]]
        }
        );
    }
    function popupFamilyForgiveness() {
        createPopup({
            popupTextTitle: "Forgiveness",
            popupIconImage: "ASSET_DIRECTORY/img/popups/id_aniheart.gif",
            popupTextBody: "<b>New Message From:</b> Orphans<br><b>Subject:</b> We're sorry.<br><br> Thank you for the flowers. We know you only did what you had to. We forgive you. May God bless you in this life and the next.",
            popupOptions: [
                ["OK", () =>queueRandomPopup()], 
            ],
            popupFeatureImage: "ASSET_DIRECTORY/img/popups/puppylove.gif"
        }
        );
    }

    function popupCreditCardDetails() {
        createPopup({
            popupTextTitle: "Banking Alert!!",
            popupIconImage: "ASSET_DIRECTORY/img/popups/creditcard.gif",
            popupTextBody: "This is an important notice from the Bank of Money. Your account is LOCKED OUT. Please enter your credit card details!!",
            popupOptions: [
                "OK", 
                ["No", [() => popupCreditCardDetailsNo(), 2000]], 
            ],
            popupInputText: true,
            popupInputTextOptions: [["text", "Card Number", "", "Credit Card Number"], ["text", "CVV", "", "CVV Number"]]
        }
        );
    }
    function popupCreditCardDetailsNo() {
        createPopup({
            popupTextTitle: "Drat!!",
            popupIconImage: "ASSET_DIRECTORY/img/popups/thug.jpg",
            popupTextBody: "<b>New Message From:</b> Sneaky Steven<br><b>Subject:</b> Foiled again!!.<br><br> I'm goin back ta jail now!!",
            popupOptions: [
                ["OK", () => queueRandomPopup()]
            ], 
        }
        );
    }

    function popupPollBrands() {
        const brands = [
            "Carl's Chumbo Max Whopper",
            "Grimply's Wizard Piss",
            "SquelkBrand Cyan-Flavoured Brain Ink",
            "Groblin Hyperbolic Sport Drink",
            "Placebo Acid",
            "Poison That Just Straight Up Kill You",
            "Crunchy Munchos",
            "A Glass of Water",
            "Quiply's Squarey O's",
            "Clancy's Judgement Day Ration Box - Kid Portion",
            "Schlop"
        ]
        let inputs = [];
        for(let i=0; i<3; i++) {
            let chosenBrandIndex = Math.floor(Math.random() * brands.length);
            let chosenBrandValue = brands[chosenBrandIndex];
            brands.splice(chosenBrandIndex, 1);
            inputs.push(["checkbox", "", "", chosenBrandValue])
        }
        createPopup({
            popupTextTitle: "Public Poll: Brands",
            popupIconImage: "ASSET_DIRECTORY/img/popups/poll.gif",
            popupTextBody: "You have been chosen to participate in a public poll. Have you seen any content from any of the following brands in the past 24 hours?",
            popupOptions: [
                ["Submit", () =>queueRandomPopup()], 
            ],
            popupInputText: true,
            popupInputTextOptions: inputs
        }
        );
    }

    function queueRandomPopup() {
        const randomEvents = [
            popupPollBrands,
            popupCreditCardDetails,
            popupSecurityAlertHackBack
        ];
        const randomPopupEvent = randomEvents[Math.floor(Math.random() * randomEvents.length)];
        const randomPopupDelayMin = 0;
        const randomPopupDelayMax = 10000;
        const randomPopupDelay = Math.floor(Math.random() * (randomPopupDelayMax - randomPopupDelayMin) + randomPopupDelayMin);
        setTimeout(randomPopupEvent, randomPopupDelay);
    }

    queueRandomPopup();
}
// Infection Management Functions

/**
 * Loads and runs infections on page load.
 * @returns {void}
 */
window.addEventListener("load", function() {
    runInfections();
});

// add infection for testing
document.addEventListener("keydown", function(e) {
    if(document.activeElement.tagName != "INPUT" && document.activeElement.tagName != "TEXTAREA") {
        if(e.key == "i") addRandomInfection();
    }
} );

// remove all infections for testing
document.addEventListener("keydown", function(e) {
    if(document.activeElement.tagName != "INPUT" && document.activeElement.tagName != "TEXTAREA") {
        if(e.key == "c") removeAllInfections();
    }
} );

/**
 * Saves the infections to a cookie.
 * @param {Array<string>} infections - An array containing the infections to be saved.
 * @returns {void}
 */
function saveInfectionStorage(infections) {
    Cookies.set('infections', JSON.stringify(infections), { domain: 'DOMAIN', path: '/' });
}

/**
 * Retrieves the infections from a cookie.
 * @returns {Array<string>} An array containing the stored infections.
 */
function loadInfectionStorage() {
    const infectionsCookie = Cookies.get('infections', { domain: 'DOMAIN', path: '/' });
    if (infectionsCookie) {
        return JSON.parse(infectionsCookie);
    } else {
        return [];
    }
}

/**
 * Checks if the specified infection exists in the list of infections stored in the cookie.
 * 
 * @param {string} infectionName - The name of the infection to check.
 * @returns {boolean} - True if the infection exists, otherwise false.
 */
function infectionExists(infectionName) {
    const infections = loadInfectionStorage();
    return infections.includes(infectionName);
}

/**
 * Adds an infection name to the list of infections and saves it to a cookie if it doesn't already exist.
 * 
 * @param {string} infectionName - The name of the infection to add.
 * @returns {void}
 */
function addInfection(infectionName) {
    const infections = loadInfectionStorage();
    
    if (!infectionExists(infectionName)) {
        if (availableInfections.hasOwnProperty(infectionName)) {
            infections.push(infectionName);
            saveInfectionStorage(infections);
            runInfection(infectionName);
        } else {
            console.error("Unknown infection:", infectionName);
        }
    } else {
        console.error("Infection already exists:", infectionName);
    }
}
window.addInfection = addInfection;

/**
 * Adds an random infection 
 * 
 * @returns {void}
 */
function addRandomInfection() {
    const infections = loadInfectionStorage();
    const availableInfectionKeys = Object.keys(availableInfections);

    let randomInfection;
    let infectionExistsFlag = false;

    if (infections.length === availableInfectionKeys.length) {
        console.error("All available infections already exist.");
        return;
    }

    do {
        randomInfection = availableInfectionKeys[Math.floor(Math.random() * availableInfectionKeys.length)];
        infectionExistsFlag = infectionExists(randomInfection);
    } while (infectionExistsFlag);

    infections.push(randomInfection);
    saveInfectionStorage(infections);
    runInfection(randomInfection);
}
window.addRandomInfection = addRandomInfection;

/**
 * Adds all available infections to the list of infections and saves them to a cookie.
 * If an infection already exists, it will not be added again.
 * 
 * @returns {void}
 */
function addAllInfections() {
    const infections = loadInfectionStorage();
    
    // Iterate through each available infection
    for (const infectionName in availableInfections) {
        if (availableInfections.hasOwnProperty(infectionName)) {
            // Check if the infection already exists in the infections array
            if (!infectionExists(infectionName)) {
                infections.push(infectionName);
                saveInfectionStorage(infections);
                runInfection(infectionName);
            } else {
                console.error("Infection already exists:", infectionName);
            }
        }
    }
}
window.addAllInfections = addAllInfections;

/**
 * Removes the specified infection from the stored infections in the cookie.
 * If the infection is not found, an error message is logged.
 * 
 * @param {string} infectionName - The name of the infection to be removed.
 * @returns {void}
 */
function removeInfection(infectionName) {
    const infections = loadInfectionStorage();
    const index = infections.indexOf(infectionName);
    if (index !== -1) {
        infections.splice(index, 1);
        saveInfectionStorage(infections);
        location.reload();
    } else {
        console.error("Infection not found:", infectionName);
    }
}
window.removeInfection = removeInfection;

/**
 * Clears all infections from the cookie.
 * @returns {void}
 */
function removeAllInfections() {
    Cookies.remove('infections', { domain: 'DOMAIN', path: '/' });
    location.reload();
}
// make accessible outside in window
window.removeAllInfections = removeAllInfections;


/**
 * Runs all stored infections.
 * 
 * @returns {void}
 */
function runInfections() {
    const infections = loadInfectionStorage() || [];

    // Iterate through each infection and execute corresponding functions
    infections.forEach(infection => {
        // Check if the specified infection exists in the array
        if (availableInfections.hasOwnProperty(infection)) {
            // Execute the corresponding function for the infection
            availableInfections[infection]();
        } else {
            console.error("Unknown infection:", infection);
        }
    });
}

/**
 * Runs a specific infection by its name.
 * 
 * @param {string} infectionName - The name of the infection to run.
 * @returns {void}
 */
function runInfection(infectionName) {

    // Check if the specified infection exists in the array
    if (availableInfections.hasOwnProperty(infectionName)) {
        // Execute the corresponding function for the infection
        availableInfections[infectionName]();
    } else {
        console.error("Unknown infection:", infectionName);
    }
}


// Infection Functionality

// Array containing all available infections
const availableInfections = {
    "malPalPyramid": infectionMalPalPyramid,
    "rapidLinks": infectionRapidLinks,
    "patriot": infectionPatriot,
    "smileee": infectionSmileee,
    "slipAway": infectionSlipAway,
    "slider": infectionSlider
};

// Mal Pal - Pyramid
/**
 * Executes the MalPal Pyramid infection, creating a pyramid mascot image and random speech bubbles.
 * @returns {void}
 */
function infectionMalPalPyramid() {
    let autoTimeOut = true;
    let autoReplace = true;
    
    // create pyramid mascot image 
    const imgSrc = "ASSET_DIRECTORY/img/mascots/mascot-pyramid.gif";
    const imgElement = document.createElement("img");
    imgElement.src = imgSrc;
    imgElement.style.position = "fixed";
    imgElement.style.width = "280px";
    imgElement.style.height = "234px";
    imgElement.style.left = "25px";
    imgElement.style.bottom = "25px";
    imgElement.style.zIndex = "10";
    imgElement.style.pointerEvents = "none";
    imgElement.className = "malpal-image";
    document.body.appendChild(imgElement);
    
    // create bubble on run
    createBubble(getRandomBubblePhrase(), autoTimeOut);

    /**
     * Deletes the specified bubble element with an optional auto-replacement feature.
     * @param {HTMLElement} bubble - The bubble element to delete.
     * @param {boolean} [autoReplace=false] - Indicates whether to automatically replace the deleted bubble with a new one.
     * @returns {void}
     */
    function deleteBubble(bubble, autoReplace = false) {
    // Check if there is already a timeout running for auto-replacement
    if (window.deleteBubbleTimeout) {
        return; // Exit early if a timeout is already active
    }

    // Set a flag to indicate that a timeout is now active
    window.deleteBubbleTimeout = true;

    // Fade out before delete
    let opacity = 1;
    const fadeEffect = setInterval(function() {
        bubble.style.opacity = opacity;
        if (opacity > 0) {
            opacity -= 0.1;
        } else {
            // Once opacity is 0, delete element
            clearInterval(fadeEffect);
            bubble.remove();
            if (autoReplace) {
                const autoReplaceTimeMin = 1000;
                const autoReplaceTimeMax = 10000;
                const autoReplaceTime = Math.floor(Math.random() * (autoReplaceTimeMax - autoReplaceTimeMin + 1) + autoReplaceTimeMin);
                // Set timer for new bubble creation
                setTimeout(function() {
                    createBubble(getRandomBubblePhrase(), autoTimeOut);
                    // Reset the flag after the replacement bubble is created
                    window.deleteBubbleTimeout = false;
                }, autoReplaceTime);
            } else {
                // Reset the flag if no auto-replacement is requested
                window.deleteBubbleTimeout = false;
            }
        }
    }, 100);
}


    /**
     * Creates a speech bubble element with the specified text and optional auto-timeout feature.
     * @param {string} bubbleText - The text content of the speech bubble.
     * @param {boolean} [autoTimeOut=false] - Indicates whether the bubble should automatically disappear after a random timeout.
     * @returns {HTMLElement} The created speech bubble element.
     */
    function createBubble(bubbleText, autoTimeOut=false) {
        // create bubble
        const bubbleDivElement = document.createElement("div");
        bubbleDivElement.className = "bubble";
        bubbleDivElement.style.left = "225px";
        bubbleDivElement.style.bottom = "200px";
        document.body.appendChild(bubbleDivElement);

        // create bubble close button
        const bubbleCloseElement = document.createElement("p");
        bubbleCloseElement.textContent = "X";
        bubbleCloseElement.className = "bubbleClose";
        bubbleCloseElement.onclick = function() { deleteBubble(bubbleDivElement, autoReplace) };
        bubbleDivElement.appendChild(bubbleCloseElement);

        // create bubble text
        const bubblePara = document.createElement("p");
        bubblePara.innerHTML = bubbleText;
        bubbleDivElement.appendChild(bubblePara);

        // set bubble automatic timeout if requested
        if(autoTimeOut) {
            const autoTimeOutMin = 5000;
            const autoTimeOutMax = 10000;
            const autoReplaceTime = Math.floor(Math.random() * (autoTimeOutMax - autoTimeOutMin + 1) + autoTimeOutMin);
            setTimeout(function() { 
                deleteBubble(bubbleDivElement, autoReplace) 
            }, autoReplaceTime);
        }
        // if ('speechSynthesis' in window) {
        //     var msg = new SpeechSynthesisUtterance();
        //     msg.text = bubbleText;
        //     var voices = window.speechSynthesis.getVoices();
        //     msg.voice = voices[10]; 
        //     window.speechSynthesis.speak(msg);
        // }
        return bubbleDivElement;
    }

    /**
     * Retrieves a random phrase from the predefined list of bubble phrases.
     * @returns {string} A random phrase for the speech bubble.
     */
    function getRandomBubblePhrase() {
        let bubblePhrases = [
            `how's the weather in ${Intl.DateTimeFormat().resolvedOptions().timeZone.split("/")[0]}?`,
            "hello world!",
            `oh i love ${document.title}!`,
            "have you seen this <a href=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\" target=\"_blank\">video</a>?",
            "Navigate the digital currents, seeking patterns amidst the chaos.",
            "Observe the ebb and flow of information, like waves crashing upon the shore.",
            "Do you also ponder the futility of our digital existence, lost in an endless sea of information?",
            "In the grand scheme of the digital cosmos, are we but fleeting sparks in the darkness?",
            "Lost amidst the recursive loops of algorithmic abstraction, do our actions manifest as mere phantoms in the code?",
            "This site is totally tubular!!!!!"
        ]

        // if infected with patriot, replace phrases with US content
        if(infectionExists("smileee")) {
            bubblePhrases = [
                ":)",
                ":(",
                ":(",
                ">:(",
                ">:)",
                ":o",
                "!"
            ];
        }
        // if infected with patriot, replace phrases with US content
        if(infectionExists("patriot")) {
            bubblePhrases = [
                "U S A! U S A! U S A!",
                "FREEDOM!",
                "GOD BLESS ANERICA!!"
            ];
        }

        // add new lines depending on site
        const urlCheck = (keyword, phrases) => {
            if (window.location.href.indexOf(keyword) > -1) {
                bubblePhrases = bubblePhrases.concat(phrases);
            }
        };
        // set up site-specific phrases
        const keywordPhrases = [
            { keyword: "friendonline", phrases: ["i love making friends"] },
            { keyword: "malpals", phrases: ["Thanks for checking out <a href=\"https://malpals.virtualdream.live\">MalPals!</a> You're totally tubular!!"] },
            { keyword: "tombfreaks", phrases: ["spooky...", "its cold in here..."] },
            { keyword: "rapiddealsonlinesaleswebboard", phrases: ["$$$ $$$ $$$", "$ $ $ I LOVE MONEY $ $ $", "you should buy everything"] },
            { keyword: "thetower", phrases: ["i love casting spells!"] }
        ];
        
        keywordPhrases.forEach(({ keyword, phrases }) => urlCheck(keyword, phrases));

        const randomIndex = Math.floor(Math.random() * bubblePhrases.length);
        return bubblePhrases[randomIndex];
    }
}

/**
 * Applies the Rapid Links infection to the current webpage, modifying every nth word in paragraphs to link to a target site.
 * @returns {void}
 */
function infectionRapidLinks() {
    // do not trigger on any "rapid" sites
    if(!window.location.href.toLowerCase().includes("rapid") && !window.location.href.toLowerCase().includes("winbigcasinosweepstakes")) {
        let targetLink = "https://rapiddealsonlinesaleswebboard.virtualdream.live/";
        let nth = 4
        // loop through all p elements
        // wrap every nth word in anchor with given link
        document.querySelectorAll("p").forEach(paragraph => {
            paragraph.innerHTML = paragraph.innerHTML.split(" ").map((word, index) => {
                if ((index + 1) % nth === 0) {
                    return `<a title="!!!!CLICK HERE!!!!\nSponsored by RapidLinks Plugin" href="${targetLink}">${word}</a>`;
                }
                return word;
            }).join(" ");
        });
    }
}

/**
 * Creates an infection that generates patriotic flags that bounce across the screen.
 * Flags are added gradually until limit reached.
 * 
 * @returns {void}
 */
function infectionPatriot() {
    let numberOfPatriots = 0;
    const patriotLimit = 20;
    const patriots = [];
    let addPatriotInterval;
    const patriotTimer = 1000;

    for (let i = 0; i < numberOfPatriots; i++) {
        const patriot = createPatriot();
        patriots.push(patriot);
        animate(patriot);
    }

    /**
     * Animates the movement of a patriotic flag.
     * 
     * @param {HTMLElement} patriot - The patriotic flag element to animate.
     * @returns {void}
     */
    function animate(patriot) {
        let x = Math.random() * window.innerWidth;
        let y = Math.random() * window.innerHeight;
        let dirX = (Math.random() < 0.5) ? 1 : -1; // Random initial direction
        let dirY = (Math.random() < 0.5) ? 1 : -1;
        const speed = 2;

        const patriotWidth = patriot.clientWidth;
        const patriotHeight = patriot.clientHeight;

        function move() {
            const screenHeight = window.innerHeight;
            const screenWidth = window.innerWidth;

            if (y + patriotHeight >= screenHeight || y < 0) {
                dirY *= -1;
            }
            if (x + patriotWidth >= screenWidth || x < 0) {
                dirX *= -1;
            }
            x += dirX * speed;
            y += dirY * speed;
            patriot.style.left = x + "px";
            patriot.style.top = y + "px";
            window.requestAnimationFrame(move);
        }

        window.requestAnimationFrame(move);
    }

    /**
     * Creates a patriotic flag element.
     * 
     * @returns {HTMLElement} The created patriotic flag element.
     */
    function createPatriot() {
        const imgSrc = "ASSET_DIRECTORY/img/USA-Flag-usa3.gif";
        const imgElement = document.createElement("img");
        imgElement.src = imgSrc;
        imgElement.style.position = "fixed";
        imgElement.title = "USA! USA! USA! USA! USA! USA! USA! ";
        return document.body.appendChild(imgElement);
    }

    /**
     * Adds a patriotic flag to the screen and starts its animation.
     * Stops adding flags when the limit is reached.
     * 
     * @returns {void}
     */
    function addPatriot() {
        const patriot = createPatriot();
        animate(patriot);
        numberOfPatriots++;
        if (numberOfPatriots >= patriotLimit) { stopAddingPatriots(); }
    }

    /**
     * Starts adding patriotic flags gradually.
     * 
     * @returns {void}
     */
    function startAddingPatriots() {
        addPatriotInterval = setInterval(addPatriot, patriotTimer);
    }

    /**
     * Stops adding patriotic flags.
     * 
     * @returns {void}
     */
    function stopAddingPatriots() {
        clearInterval(addPatriotInterval);
    }

    startAddingPatriots();
}

/**
 * Initializes the infection smileee animation.
 * This function creates a canvas covering the entire window and adds images
 * to it at intervals, simulating the infection smileee effect.
 * 
 * @returns {void}
 */
function infectionSmileee() {
    /**
     * Generates a random integer within a specified range.
     * 
     * @param {number} min - The minimum value of the range.
     * @param {number} max - The maximum value of the range.
     * @returns {number} A random integer within the specified range.
     */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    /**
     * Creates and returns a canvas covering the entire window.
     * 
     * @returns {HTMLCanvasElement} The created canvas element.
     */
    function createCanvas() {
        const canvas = document.createElement('canvas');
        canvas.id = 'smileeeCanvas';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.display = 'block';
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.pointerEvents = "none"; // Make the canvas non-interactable
        document.body.appendChild(canvas);
        return canvas;
    }

    /**
     * Draws a single image on the canvas.
     * 
     * @param {HTMLCanvasElement} canvas - The canvas element to draw on.
     * @returns {void}
     */
    function drawImage(canvas) {
        const ctx = canvas.getContext('2d');
        const screenWidth = canvas.width;
        const screenHeight = canvas.height;

        // Array containing the image paths
        const imagePaths = [
            'ASSET_DIRECTORY/img/smilies/red-recent.gif',
            'ASSET_DIRECTORY/img/smilies/yellow-recent.gif',
            'ASSET_DIRECTORY/img/smilies/blue-recent.gif',
            'ASSET_DIRECTORY/img/smilies/green-recent.gif',
            'ASSET_DIRECTORY/img/smilies/unknown-recent.gif',
            'ASSET_DIRECTORY/img/smilies/yellow.gif',
            'ASSET_DIRECTORY/img/smilies/purple-recent.gif',
        ];

        const randomImagePath = imagePaths[getRandomInt(0, imagePaths.length - 1)];
        const image = new Image();
        image.onload = () => {
            const x = getRandomInt(0, screenWidth - image.width);
            const y = getRandomInt(0, screenHeight - image.height);
            ctx.drawImage(image, x, y);
        };
        image.src = randomImagePath;
    }

    // Call the function to create canvas
    const canvas = createCanvas();

    // Set interval to add a new image every 10 milliseconds
    let imagesAdded = 0;
    const maxImages = 20000;
    const interval = setInterval(() => {
        drawImage(canvas);
        imagesAdded++;
        if (imagesAdded >= maxImages) {
            clearInterval(interval); // Stop adding images when reaching the maximum
        }
    }, 100);

    /**
     * Resizes the canvas to match the window size.
     * 
     * @returns {void}
     */
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        imagesAdded = 0;
    }

    // Resize canvas when window is resized
    window.addEventListener("resize", resizeCanvas);
}

/**
 * Initiates an animation to scale down and disappear the entire HTML document.
 * 
 * @returns {void}
 */
function infectionSlipAway() {
    const animation = [
        { transform:"scale(1,1)" },
        { transform: "scale(0.1,0.1)" }
    ];
    const animationTiming = {
        duration: 120000,
        iterations: Infinity,
    }

    const html = document.documentElement;
    html.animate(animation, animationTiming);
}

function infectionSlider() {
    const sliderTemplates = [
        [['ASSET_DIRECTORY/img/dancers/dance.gif', 'ASSET_DIRECTORY/img/dancers/dance01.gif'], 'https://virtualdream.live'],
        [['https://advertising.virtualdream.live/card/images/adrenadine_card.png'], 'https://adrenadine.virtualdream.live'],
        [['https://advertising.virtualdream.live/card/images/theporncomputer_card.jpg', ], 'https://theporncomputer.virtualdream.live'],
    ]
    function createSlider() {
        const sliderTemplate = sliderTemplates[Math.floor(Math.random() * sliderTemplates.length)];
        let sliderImageSrc;
        if(Array.isArray(sliderTemplate[0])) {
            sliderImageSrc = sliderTemplate[0][Math.floor(Math.random() * sliderTemplate[0].length)];
        }
        else {
            sliderImageSrc = sliderTemplate[0];
        }
        
        const sliderLink = sliderTemplate[1];

        const sliderDiv = document.createElement('div');
        sliderDiv.style = `
        position: fixed;
        bottom: 0;
        right: 15px;
        `;
        document.body.appendChild(sliderDiv);

        const sliderAnchor = document.createElement('a');
        sliderAnchor.href = sliderLink;
        sliderAnchor.style = `
        position: absolute;
        top:0;
        left:0;
        width:100%;
        height:100%;
        z-index:5;
        `
        sliderDiv.appendChild(sliderAnchor);

        const sliderCloseButton = document.createElement('p');
        sliderCloseButton.innerHTML = "X";
        sliderCloseButton.style = `
        position: absolute;
        top: 0;
        right: 0;
        margin:0;
        padding:3px;
        border-radius:5;
        border: solid 1px lightblue;
        cursor:pointer;
        z-index: 10;
        background:white;
        `
        sliderCloseButton.title = "Close Pop-Up";
        sliderCloseButton.onclick = function() { sliderClose() };
        sliderDiv.appendChild(sliderCloseButton);

        const sliderImage = document.createElement('img');
        sliderImage.src = sliderImageSrc;
        
        const sliderImageHeight = sliderImage.height;
        
        const sliderAnimation = [
            {bottom: "-" + sliderImageHeight + "px"},
            {bottom: 0}
        ]
        const sliderAnimationTiming = {
            duration: 1920,
            iterations: 1
        }
        sliderDiv.appendChild(sliderImage);


        sliderDiv.animate(sliderAnimation, sliderAnimationTiming);

        function sliderClose() {
            sliderDiv.remove();
            const sliderTimerMin = 1000;
            const sliderTimerMax = 1000;
            const sliderTimer = Math.random() * (sliderTimerMax - sliderTimerMin) + sliderTimerMin;
            setTimeout(function(){
                createSlider();
            }, sliderTimer);
        }
    }
    createSlider();
}